#!/usr/bin/env node

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

require('./lib/test_env.js');

const assert = require('assert'),
  vows = require('vows'),
  start_stop = require('./lib/start-stop.js'),
  wsapi = require('./lib/wsapi.js'),
  config = require('../lib/configuration.js');

var suite = vows.describe('session-context');

// disable vows (often flakey?) async error behavior
suite.options.error = false;

start_stop.addStartupBatches(suite);

const TEST_EMAIL = 'someuser@somedomain.com',
  PASSWORD = 'thisismypassword';

var token = undefined;

// first stage the account
suite.addBatch({
  'account staging': {
    topic: wsapi.post('/wsapi/stage_user', {
      email: TEST_EMAIL,
      pass: PASSWORD,
      site: 'https://fakesite.com',
    }),
    works: function (err, r) {
      assert.equal(r.code, 200);
    },
  },
});

// wait for the token
suite.addBatch({
  'a token': {
    topic: function () {
      start_stop.waitForToken(this.callback);
    },
    'is obtained': function (err, t) {
      assert.isNull(err);
      assert.strictEqual(typeof t, 'string');
      token = t;
    },
  },
});

// create a new account via the api with (first address)
suite.addBatch({
  'setting password': {
    topic: function () {
      wsapi
        .post('/wsapi/complete_user_creation', {
          token: token,
        })
        .call(this);
    },
    'works just fine': function (err, r) {
      assert.equal(r.code, 200);
    },
  },
});

suite.addBatch({
  'authenticating with the password': {
    topic: wsapi.post('/wsapi/authenticate_user', {
      email: TEST_EMAIL,
      pass: PASSWORD,
      ephemeral: true,
    }),
    'works as expected': function (err, r) {
      assert.strictEqual(JSON.parse(r.body).success, true);
    },
  },
});

suite.addBatch({
  'session context': {
    topic: wsapi.get('/wsapi/session_context'),
    'contains values expected': function (err, r) {
      assert.isNull(err);
      var resp = JSON.parse(r.body);
      assert.strictEqual(typeof resp.csrf_token, 'string');
      var serverTime = new Date(resp.server_time);
      assert.ok(new Date() - serverTime < 5000);
      assert.strictEqual(resp.authenticated, true);
      assert.strictEqual(resp.auth_level, 'password');
      var domainKeyCreation = new Date(resp.domain_key_creation_time);
      assert.ok(new Date() - serverTime < 365 * 24 * 60 * 60 * 1000);
      assert.strictEqual(typeof resp.random_seed, 'string');
      assert.strictEqual(resp.userid, 1);
    },
  },
});

suite.addBatch({
  'code version mismatch using session_context API': {
    topic: wsapi.get(
      '/wsapi/session_context',
      {},
      {
        headers: {
          'BrowserID-git-sha': 'INVALID_SHA',
        },
      }
    ),
    'will still respond correctly': function (err, r) {
      assert.equal(r.code, 200);
    },
  },
});

suite.addBatch({
  'cookie check using session_context': {
    'with can_set_cookie cookie': {
      topic: wsapi.get(
        '/wsapi/session_context',
        {},
        {
          cookieJar: {
            can_set_cookies: '1',
          },
        }
      ),
      "responds with 'cookies=true' in response": function (err, r) {
        var body = JSON.parse(r.body);
        assert.equal(body.cookies, true);
      },
    },
    'without can_set_cookie_cookies': {
      topic: wsapi.get('/wsapi/session_context', {}, {}),
      "responds with 'cookies=false' in response": function (err, r) {
        var body = JSON.parse(r.body);
        assert.equal(body.cookies, false);
      },
    },
  },
});

start_stop.addShutdownBatches(suite);

// run or export the suite.
if (process.argv[1] === __filename) suite.run();
else suite.export(module);
